paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
opt_pars=parEstimationLBode(cnolist, model, method="essm", ode_parameters=ode_parameters, paramsSSm=paramsSSm)
simData = plotLBodeFitness(cnolist = cnolist, model = model, ode_parameters = opt_pars, transfer_function = 4)
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist, indices = indices, database = NULL, DDN = TRUE)
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist)
plotModel(model = integratedModel$model, CNOlist = cnolist, indexIntegr = integratedModel$integLinksIdx)
ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
dev.off()
res1 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 2)
plotLBodeFitness(cnolist = res1$CNOList, model = res1$`Integrated-Model`$model, ode_parameters = res1$Parameters, transfer_function = 4)
dev.off()
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 100)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 1000)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
integratedModel$model$reacID
integratedModel$databaseWeight
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 100)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
rm(res2)
dev.off()
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, penFactor_k = 100, paramsSSm = paramsSSm)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, penFactor_k = 10000, paramsSSm = paramsSSm)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
rm(list = ls())
library(CARNIVAL) # load CARNIVAL library
#Load files
file.copy(from=system.file(“SBV_EGF_tvalues.csv”,package=“CARNIVAL”),to=getwd(),overwrite=TRUE)
file.copy(from=system.file(“dorothea_TF_mapping.csv”,package=“CARNIVAL”),to=getwd(),overwrite=TRUE)
load(file = system.file(“BEST_viperRegulon.rdata”,package=“CARNIVAL”))
df<-read.csv2(“SBV_EGF_tvalues.csv”, row.names = ‘GeneName’)
map<-read.csv(“dorothea_TF_mapping.csv”)
#Run DoRothEA and convert from gene symbol to uniprot ID
TF_genesymbol<-runDoRothEA(df, regulon=viper_regulon, confidence_level=c(‘A’,‘B’,‘C’))
library(CARNIVAL) # load CARNIVAL library
#Load files
file.copy(from=system.file("SBV_EGF_tvalues.csv",package="CARNIVAL"),to=getwd(),overwrite=TRUE)
file.copy(from=system.file("BEST_viperRegulon.rdata",package="CARNIVAL"),to=getwd(),overwrite=TRUE)
load(file = system.file("BEST_viperRegulon.rdata",package="CARNIVAL"))
df<-read.csv2("SBV_EGF_tvalues.csv", row.names = 'GeneName')
map<-read.csv("dorothea_TF_mapping.csv")
#Run DoRothEA and convert from gene symbol to uniprot ID
TF_genesymbol<-runDoRothEA(df, regulon=viper_regulon, confidence_level=c('A','B','C'))
library(CARNIVAL) # load CARNIVAL library
#Load files
file.copy(from=system.file("SBV_EGF_tvalues.csv",package="CARNIVAL"),to=getwd(),overwrite=TRUE)
file.copy(from=system.file("BEST_viperRegulon.rdata",package="CARNIVAL"),to=getwd(),overwrite=TRUE)
load(file = system.file("BEST_viperRegulon.rdata",package="CARNIVAL"))
df<-read.csv2("SBV_EGF_tvalues.csv", row.names = 'GeneName')
map<-read.csv("dorothea_TF_mapping.csv")
#Run DoRothEA and convert from gene symbol to uniprot ID
TF_genesymbol<-runDoRothEA(df, regulon=viper_regulon, confidence_level=c('A','B','C'))
TF_genesymbol
sessionInfo()
rm(list)
rm(list = ls())
library(CellNOptR)
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
pknmodel = ToyModel
cnolist = CNOlist(CNOlistToy)
model = preprocessing(cnolist, pknmodel)
resILP = ilpBinaryT1(cnolist = cnolist, model = model, numSolutions = 5)
library(readr)
resILP = ilpBinaryT1(cnolist = cnolist, model = model, numSolutions = 5)
library(stringr)
resILP = ilpBinaryT1(cnolist = cnolist, model = model, numSolutions = 5)
resILP
resILP = ilpBinaryT1(cnolist = cnolist, model = model, numSolutions = 3)
resILP$bitstringILP
cutAndPlot(CNOlist = cnolist, model = model, bStrings = resILP$bitstringILP[[1]])
cutAndPlot(CNOlist = cnolist, model = model, bStrings = list(resILP$bitstringILP[[1]]))
res = gaBinaryT1(cnolist, model, verbose=FALSE)
plotModel(model = model, CNOlist = cnolist)
cutAndPlot(cnolist, model, list(res$bString))
cutAndPlot(CNOlist = cnolist, model = model, bStrings = list(resILP$bitstringILP[[1]]))
cutAndPlot(CNOlist = cnolist, model = model, bStrings = list(resILP$bitstringILP[[2]]))
cutAndPlot(CNOlist = cnolist, model = model, bStrings = list(resILP$bitstringILP[[3]]))
dev.off()
vignette("CellNOptR")
vignette()
vignette("01-Working_with_large_arrays")
vignette("CellNOptR")
vignette("CellNOptR")
vignette(CellNOptR)
library(Biobase)
openVignette(package = "CellNOptR")
installed.packages(knitr)
install.packages('knitr', dependencies = TRUE)
library(knitr)
knit2pdf(input = "~/Documents/vignettes/CNORfeeder-vignette.Rnw", output = "~/Documents/vignettes/CNORfeeder-vignette.pdf")
rm(list = ls())
setwd("~/Documents/GitHub/CellNOpt-Feeder/vignettes/")
library(devtools)
install_github('saezlab/CellNOpt-Feeder')
dev.off()
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
vignette("CNORfeeder-vignette")
vignette("CNORfeeder-vignette")
remove.packages(CNORfeeder)
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(CNORfeeder)
vignette("CNORfeeder-vignette")
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(CNORfeeder)
vignette("CNORfeeder-vignette")
vignette("CNORfeeder-vignette")
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
remove.packages("CNORfeeder")
vignette("CNORfeeder-vignette")
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(CNORfeeder)
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(CNORfeeder)
vignette("CNORfeeder-vignette")
getwd()
remove.packages(CellNOptR)
library(devtools)
devtools::install_github("saezlab/CellNOptR", ref="ilp", build_vignettes = TRUE)
remove.packages("CellNOptR")
library(devtools)
devtools::install_github("saezlab/CellNOptR", ref="ilp", build_vignettes = TRUE)
library(CellNOptR)
vignette("CellNOptR-vignette")
remove.packages("CNORode")
library(devtools)
install_github("saezlab/CNORode",ref="crossval", build_vignettes = TRUE)
library(CNORode)
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder', build_vignettes = TRUE)
library(CNORfeeder)
vignette("CNORfeeder-vignette")
vignette("CellNOptR-vignette")
vignette("CNORode-vignette")
library("CARNIVAL")
?runCARNIVAL
?runPROGENy
library(OmnipathR)
interactions <-
import_Omnipath_Interactions(filter_databases=c())
interactions = interactions[which(sum(interactions$is_stimulation+interactions$is_inhibition)==1), ]
interactions <-
import_Omnipath_Interactions(filter_databases=c())
interactions = interactions[which((interactions$is_stimulation+interactions$is_inhibition)==1), ]
library("CNORode")
vignette("CNORode-vignette")
library(CNORode)
model=readSIF(system.file("extdata", "ToyModelMMB_FeedbackAnd.sif",
package="CNORode"));
cno_data=readMIDAS(system.file("extdata", "ToyModelMMB_FeedbackAnd.csv",
package="CNORode"));
cnolist=makeCNOlist(cno_data,subfield=FALSE);
plotModel(model = model, CNOlist = cnolist)
plotCNOlist(CNOlist = cnolist)
library(MEIGOR)
f_hepato<-getLBodeContObjFunction(cnolist, model, initial_pars, indices=NULL,
time = 1, verbose = 0, transfer_function = 2, reltol = 1e-05, atol = 1e-03,
maxStepSize = Inf, maxNumSteps = 1e4, maxErrTestsFails = 50, nan_fac = 1)
n_pars=length(initial_pars$LB);
problem<-list(f=f_hepato, x_L=initial_pars$LB[initial_pars$index_opt_pars],
x_U=initial_pars$UB[initial_pars$index_opt_pars]);
#Source a function containing the options used in the CeSSR publication
source(system.file("benchmarks","get_paper_settings.R",package="MEIGOR"))
#Set max time as 20 seconds per iteration
opts<-get_paper_settings(20);
Results<-CeSSR(problem,opts,Inf,Inf,3,TRUE,global_save_list=c('cnolist','model',
'initial_pars'))
library(MEIGOR)
source(system.file("benchmarks","get_paper_settings.R",package="MEIGOR"))
library(CellNOptR)
library(CNORode)
library(MEIGOR)
# MacNamara et al. 2012 case study:
data(PKN_ToyPB, package="CellNOptR")
data(CNOlist_ToyPB, package="CellNOptR")
# original and preprocessed network
plotModel(pknmodel, cnodata)
model = preprocessing(data = cnodata, model = pknmodel,
compression = T, expansion = T)
plotModel(model, cnodata)
plotCNOlist(CNOlist = cnodata)
# set initial parameters
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 4, UB_k = 1,
UB_tau = 1, default_n = 3, default_k = 0.5,
default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 600;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=0;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
transferFun=4;
paramsSSm$transfer_function = transferFun;
paramsSSm$lambda_tau=0
paramsSSm$lambda_k=0
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
# run the optimisation algorithm
opt_pars=parEstimationLBode(cnodata,model, method="essm",
ode_parameters=ode_parameters, paramsSSm=paramsSSm)
library(doParallel)
R=crossvalidateODE(CNOlist = cnodata, model = model,
type="datapoint", nfolds=3, parallel = TRUE,
ode_parameters = ode_parameters, paramsSSm = paramsSSm)
rm(list = ls())
remove.packages("CNORode")
library(devtools)
install_github("saezlab/CNORode",ref="crossval", build_vignettes = TRUE)
library(CNORode)
?crossvalidateODE
library(CNORfeeder)
vignette("CNORfeeder-vignette")
data(CNOlistDREAM,package="CellNOptR")
data(DreamModel,package="CellNOptR")
BTable <- makeBTables(CNOlist=CNOlistDREAM, k=2, measErr=c(0.1, 0))
Lrank <- linksRanking(CNOlist=CNOlistDREAM, measErr=c(0.1, 0), savefile=FALSE)
model<-preprocessing(data=CNOlistDREAM, model=DreamModel)
modelIntegr <- mapBTables2model(BTable=BTable,model=model,allInter=TRUE)
plotModel(model=modelIntegr, CNOlist=CNOlistDREAM, indexIntegr=modelIntegr$indexIntegr)
modelIntegrWeight <- weighting(modelIntegr=modelIntegr, PKNmodel=DreamModel,
CNOlist=CNOlistDREAM, integrFac=10)
data(PPINigraph,package="CNORfeeder")
data(UniprotIDdream,package="CNORfeeder")
modelIntegrWeight <- weighting(modelIntegr=modelIntegr, PKNmodel=DreamModel,
CNOlist=CNOlistDREAM, integrFac=10,
UniprotID=UniprotIDdream, PPI=PPINigraph)
initBstring<-rep(1,length(modelIntegrWeight$reacID))
DreamT1opt<-gaBinaryT1W(CNOlist=CNOlistDREAM, model=modelIntegrWeight,
initBstring=initBstring, maxGens=2, popSize=5, verbose=FALSE)
plotModel(model=modelIntegrWeight, CNOlist=CNOlistDREAM, bString=DreamT1opt$bString)
dev.off()
library(CellNOptR)
vignette("CellNOptR-vignette")
vignette("CARNIVAL-vignette")
setwd("~/Documents/GitHub/CARNIVAL-Bioconductor-Dev/R/")
library(CARNIVAL)
load(file = system.file("Ex2_inputs_SBV_EGF.RData",
package="CARNIVAL"))
load(file = system.file("Ex2_measurements_SBV_EGF.RData",
package="CARNIVAL"))
load(file = system.file("Ex2_network_SBV_Omnipath.RData",
package="CARNIVAL"))
load(file = system.file("Ex2_weights_SBV_EGF.RData",
package="CARNIVAL"))
measObj = Ex2_measurements_SBV_EGF
class(measObj)
class(measObj)=="data.frame"
netObj
netObj=Ex2_network_SBV_Omnipath
class(netObj)
allowedClass = c("matrix", "data.frame")
!(class(netObj)%in%allowedClass)
any((class(netObj)%in%allowedClass))
inputObj=Ex2_inputs_SBV_EGF
measObj[1, ]
class(measObj[1, ])
measObj$Q16254
#'\code{checkMeasObj}
#'
#'@param measObj Measurement object
#'
#'@return Error message in case of errors in the inputs
#'
#'@export
checkMeasObj <- function(measObj = measObj, netObj = netObj){
returnList = list()
nSpecies = unique(c(as.character(as.matrix(netObj)[, 1]), as.character(as.matrix(netObj)[, 3])))
if (is.null(measObj)) {
stop("Please provide a valid measurement object.")
} else {
allowedClass = c("matrix", "data.frame")
if(!(any(class(measObj)%in%allowedClass))){
stop("Measurement object should either be of matrix or data.frame class")
} else {
if(ncol(measObj)>0){
mSpecies = colnames(measObj)
idx = which(mSpecies%in%nSpecies)
idx2rem = setdiff(1:length(mSpecies), idx)
if(length(idx2rem)==length(mSpecies)){
stop("Something wrong with your measurements object/network object. No measurements is present in the network")
} else {
if(length(idx2rem)>0){
if(nrow(measObj)==1){
measObj = measObj[, -idx2rem]
measObj = t(as.matrix(measObj))
} else {
measObj = measObj[, -idx2rem]
}
}
}
} else {
stop("Something wrong with your measurements object. Please check.")
}
}
}
return(measObj)
}
measObj = checkMeasObj(measObj = measObj, netObj = netObj)
measObj
measObj = Ex2_measurements_SBV_EGF
measObj
measObj = checkMeasObj(measObj = measObj, netObj = netObj)
names(measObj)
measObj
measObj = Ex2_measurements_SBV_EGF
nrow(measObj)
class(measObj)
tt = as.matrix(measObj)
tt[, -c(1, 10)]
kk = tt[, -c(1, 10)]
kk
kk = as.matrix(kk)
kk
kk = tt[, -c(1, 10)]
kk
kk = t(as.matrix(kk))
kk
#'\code{checkMeasObj}
#'
#'@param measObj Measurement object
#'
#'@return Error message in case of errors in the inputs
#'
#'@export
checkMeasObj <- function(measObj = measObj, netObj = netObj){
returnList = list()
nSpecies = unique(c(as.character(as.matrix(netObj)[, 1]),
as.character(as.matrix(netObj)[, 3])))
if (is.null(measObj)) {
stop("Please provide a valid measurement object.")
} else {
allowedClass = c("matrix", "data.frame")
if(!(any(class(measObj)%in%allowedClass))){
stop("Measurement object should either be of matrix or data.frame class")
} else {
if(ncol(measObj)>0){
mSpecies = colnames(measObj)
idx = which(mSpecies%in%nSpecies)
idx2rem = setdiff(1:length(mSpecies), idx)
if(length(idx2rem)==length(mSpecies)){
stop("Something wrong with your measurements object/network object.
No measurements is present in the network")
} else {
if(length(idx2rem)>0){
if((nrow(measObj)==1) && (class(measObj)=="matrix")){
measObj = measObj[, -idx2rem]
measObj = t(as.matrix(measObj))
} else {
measObj = measObj[, -idx2rem]
}
}
}
} else {
stop("Something wrong with your measurements object. Please check.")
}
}
}
return(measObj)
}
measObj = checkMeasObj(measObj = measObj, netObj = netObj)
measObj
class(measObj)
inputObj = Ex2_inputs_SBV_EGF
inputObj
MappedPertNode <- AddPerturbationNode(network = netObj)
MappedPertNode$inputs
returnList = MappedPertNode
returnList$inputs
names(returnList)
#'\code{checkInputObj}
#'
#'@param inputObj Input object
#'
#'@return Error message in case of errors in the inputs
#'
#'@export
checkInputObj <- function(inputObj = inputObj, netObj = netObj){
nSpecies = unique(c(as.character(as.matrix(netObj)[, 1]),
as.character(as.matrix(netObj)[, 3])))
returnList = list()
if(is.null(inputObj)){
print("inputObj set to NULL -- running InvCARNIVAL")
MappedPertNode <- AddPerturbationNode(network = netObj)
returnList = MappedPertNode
} else {
if(ncol(inputObj)>0){
mSpecies = colnames(inputObj)
} else {
stop("Something wrong with your measurements object. Please check.")
}
idx = which(mSpecies%in%nSpecies)
idx2rem = setdiff(1:length(mSpecies), idx)
if(length(idx2rem)==length(mSpecies)){
stop("Something wrong with your measurements object/network object.
No input is present in the network")
} else {
if(length(idx2rem)>0){
if((nrow(inputObj)==1) && (class(inputObj)=="matrix")){
inputObj = inputObj[, -idx2rem]
inputObj = t(as.matrix(inputObj))
} else {
inputObj = inputObj[, -idx2rem]
}
}
}
returnList[[length(returnList)+1]] = inputObj
returnList[[length(returnList)+1]] = netObj
names(returnList) = c("inputs", "network")
}
return(returnList)
}
inputObj = checkInputObj(inputObj = inputObj, netObj = netObj)
inputObj
inputObj$inputs
idx2rem = which(duplicated(netObj[, c(1, 3)]))
idx2rem
length(idx2rem)
mm = matrix(data = , nrow = 3, ncol = 3)
mm[1, ] = c(1, 2, 3)
View(mm)
mm[2, ] = c(4, 5, 6)
mm[3, ] = c(1, 7, 3)
which(duplicated(mm[, c(1, 3)]))
#'\code{checkSolver}
#'
#'Run CARNIVAL pipeline using to the user-provided list of inputs or run
#'CARNIVAL built-in examples
#'Note: The pipeline requires either all required user-defined input variables
#'(netObj and measObj) are set to NULL or CARNIVAL_example is set to NULL to
#'execute
#'
#'@param solverPath Path to executable cplex file - always required
#'@param solver Solver name
#'@param dir_name Name of directory where to store DOT result
#'
#'@return Error message in case of errors in the inputs
#'
#'@export
checkSolver <- function(solverPath = solverPath, solver = solver,
dir_name = dir_name){
if(!(class(solverPath)=="character")){
stop("SolverPath should be of type character")
} else {
if(!file.exists(solverPath)){
stop("Please provide a valid path to interactive solver")
}
}
if(!(class(solver)=="character")){
stop("solver should be of type character")
} else {
# checking for solver validity (cplex/cbc)
valid_solver_list <- c("cplex", "cbc")
if (!(solver %in% valid_solver_list)){
stop(paste0("Select a valid solver option (",
paste(valid_solver_list, collapse=", "), ")"))
}
}
if(!is.null(dir_name)){
if(!(class(dir_name)=="character")){
stop("dir_name should either be NULL or provided as a character")
}
}
}
timelimit=600
class(timelimit)
